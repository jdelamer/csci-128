\documentclass{csbeamer}

\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}

% Python code styling
\lstset{
    language=Python,
    basicstyle=\ttfamily\scriptsize,
    keywordstyle=\color{blue}\bfseries,
    stringstyle=\color{red},
    commentstyle=\color{green!50!black}\itshape,
    showstringspaces=false,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray}
}

% Course information
\title{Picture Manipulation and Filters}
\course{CSCI 128: Coding for Problem Solving}
\courseshort{CSCI 128}
\term{Winter 2026}
\author{Dr. Jean-Alexis Delamer}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{Today's Topics}
    \begin{center}
        \Large Creating your first image filters!
    \end{center}

    \vspace{1em}

    \textbf{Learning Objectives:}
    \begin{itemize}
        \item<1-> Process \textcolor{marigold}{all pixels} in an image
        \item<2-> Create \textcolor{stfxblue}{grayscale} conversion
        \item<3-> Build a \textcolor{marigold}{negative} filter
        \item<4-> Adjust \textcolor{stfxblue}{brightness}
        \item<5-> Apply \textcolor{marigold}{tinting} effects
        \item<6-> Understand image algorithms
    \end{itemize}

    \vspace{1em}

    \begin{center}
        \onslide<7->{\textit{By the end of today, you'll have your own \textcolor{marigold}{\textbf{Instagram-like filters!}}}}
    \end{center}
\end{frame}

\begin{frame}{Review: What We Know}
    \textbf{From last class:}
    \begin{itemize}
        \item<1-> Images are \textcolor{stfxblue}{grids of pixels}
        \item<2-> Each pixel has an \textcolor{marigold}{RGB color} (R, G, B) from 0-255
        \item<3-> We can access pixels with \texttt{getpixel()} and \texttt{putpixel()}
        \item<4-> Coordinate system: (0,0) is top-left
    \end{itemize}

    \vspace{1em}

    \pause

    \textbf{Today we'll:}
    \begin{itemize}
        \item<6-> Process \textcolor{marigold}{\textit{all}} pixels in an image
        \item<7-> Apply mathematical transformations to colors
        \item<8-> Create \textcolor{stfxblue}{visible, dramatic} effects
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{The Standard Pattern: Processing All Pixels}
    \textbf{This is the fundamental structure for image manipulation:}

    \begin{lstlisting}
from PIL import Image

img = Image.open("photo.jpg")
pixels = img.load()
width, height = img.size

# Process every pixel
for x in range(width):
    for y in range(height):
        # Get current color
        r, g, b = pixels[x, y]
        # Calculate new color
        new_r, new_g, new_b = # ... transformation ...
        # Set new color
        pixels[x, y] = (new_r, new_g, new_b)
img.show()
    \end{lstlisting}
\end{frame}

\begin{frame}{Understanding the Nested Loop}
    \textbf{Why \textcolor{stfxblue}{nested loops}?}

    \vspace{1em}

    \begin{itemize}
        \item<1-> Images are \textcolor{marigold}{2D grids}
        \item<2-> Outer loop: iterates through columns (x)
        \item<3-> Inner loop: iterates through rows (y)
        \item<4-> Together: visit \textcolor{stfxblue}{every pixel exactly once}
    \end{itemize}

    \vspace{1em}

    \pause

    \textbf{For a 800×600 image:}
    \begin{itemize}
        \item<6-> Outer loop runs 800 times
        \item<7-> Inner loop runs 600 times for each x
        \item<8-> Total iterations: \textcolor{marigold}{\textbf{800 × 600 = 480,000}}
    \end{itemize}

    \vspace{1em}

    \begin{center}
        \onslide<9->{This is why image processing can be \textcolor{red}{slow} on large images!}
    \end{center}
\end{frame}

\begin{frame}{Our First Filter: Grayscale}
    \textbf{What is \textcolor{stfxblue}{grayscale}?}
    \begin{itemize}
        \item<1-> A black-and-white image
        \item<2-> Each pixel is a shade of \textcolor{stfxblue}{gray}
        \item<3-> No color - only \textcolor{marigold}{brightness} information
    \end{itemize}

    \vspace{1em}

    \pause

    \textbf{How to convert to grayscale?}
    \begin{itemize}
        \item<5-> Remember: When \textcolor{marigold}{R = G = B}, we get gray
        \item<6-> We need to calculate a single "brightness" value
        \item<7-> Use that value for all three color channels
    \end{itemize}

    \vspace{1em}

    \pause

    \textbf{Simple approach:} Average the RGB values
    \begin{center}
        \onslide<9->{\textcolor{stfxblue}{$\text{gray} = \frac{R + G + B}{3}$}}
    \end{center}
\end{frame}

\begin{frame}[fragile]{Grayscale: Simple Average}
    \begin{lstlisting}
from PIL import Image

img = Image.open("photo.jpg")
pixels = img.load()
width, height = img.size

for x in range(width):
    for y in range(height):
        r, g, b = pixels[x, y]

        # Calculate average
        gray = (r + g + b) // 3

        # Set all channels to the same value
        pixels[x, y] = (gray, gray, gray)

img.save("grayscale.jpg")
img.show()
    \end{lstlisting}

    \textbf{Note:} We use \texttt{//} for integer division
\end{frame}

\begin{frame}{Better Grayscale: Luminance}
    \textbf{Problem with simple average:}
    \begin{itemize}
        \item<1-> Human eyes don't perceive all colors equally
        \item<2-> We're more sensitive to \textcolor{green!50!black}{green}
        \item<3-> Less sensitive to \textcolor{blue}{blue}
    \end{itemize}

    \vspace{1em}

    \pause

    \textbf{Better formula (\textcolor{marigold}{luminance}):}
    \begin{center}
        \onslide<5->{\textcolor{stfxblue}{$\text{gray} = 0.299 \times R + 0.587 \times G + 0.114 \times B$}}
    \end{center}

    \vspace{1em}

    \pause

    \textbf{These weights approximate human vision:}
    \begin{itemize}
        \item<7-> \textcolor{green!50!black}{Green} contributes most (58.7\%)
        \item<8-> \textcolor{red}{Red} contributes next (29.9\%)
        \item<9-> \textcolor{blue}{Blue} contributes least (11.4\%)
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Grayscale: Luminance Method}
    \begin{lstlisting}
from PIL import Image

img = Image.open("photo.jpg")
pixels = img.load()
width, height = img.size

for x in range(width):
    for y in range(height):
        r, g, b = pixels[x, y]

        # Calculate luminance
        gray = int(0.299 * r + 0.587 * g + 0.114 * b)

        # Set all channels to the same value
        pixels[x, y] = (gray, gray, gray)

img.save("grayscale_luminance.jpg")
img.show()
    \end{lstlisting}

    This produces more \textcolor{marigold}{natural-looking} grayscale images!
\end{frame}

\begin{frame}[fragile]{Try It: Grayscale Filter}
    \begin{center}
        \Large \textbf{Activity Time!}
    \end{center}

    \vspace{1em}

    \textbf{Task:}
    \begin{enumerate}
        \item Choose an image (photo of yourself, a landscape, etc.)
        \item Write a program to convert it to grayscale
        \item Try both methods (average and luminance)
        \item Save both results
        \item Compare them - can you see the difference?
    \end{enumerate}

    \vspace{1em}

    \textbf{Bonus:} Try it on different types of images - portraits, landscapes, graphics
\end{frame}

\begin{frame}{The Negative Filter}
    \textbf{What is a \textcolor{marigold}{negative} image?}
    \begin{itemize}
        \item<1-> Like a film negative in photography
        \item<2-> Light areas become \textcolor{stfxblue}{dark}
        \item<3-> Dark areas become \textcolor{stfxblue}{light}
        \item<4-> Colors are \textcolor{marigold}{inverted}
    \end{itemize}

    \vspace{1em}

    \pause

    \textbf{How to create it?}
    \begin{itemize}
        \item<6-> Subtract each color value from \textcolor{stfxblue}{255}
        \item<7-> $\text{new\_red} = 255 - \text{old\_red}$
        \item<8-> $\text{new\_green} = 255 - \text{old\_green}$
        \item<9-> $\text{new\_blue} = 255 - \text{old\_blue}$
    \end{itemize}

    \pause

    \textbf{Example:} \textcolor{red}{Red (255, 0, 0)} becomes \textcolor{cyan}{Cyan (0, 255, 255)}
\end{frame}

\begin{frame}[fragile]{Creating a Negative}
    \begin{lstlisting}
from PIL import Image
img = Image.open("photo.jpg")
pixels = img.load()
width, height = img.size

for x in range(width):
    for y in range(height):
        r, g, b = pixels[x, y]
        # Invert each color channel
        new_r = 255 - r
        new_g = 255 - g
        new_b = 255 - b

        pixels[x, y] = (new_r, new_g, new_b)

img.save("negative.jpg")
img.show()
    \end{lstlisting}

    \textbf{Simple but \textcolor{marigold}{dramatic} effect!}
\end{frame}

\begin{frame}[fragile]{Try It: Negative Filter}
    \begin{center}
        \Large \textbf{Activity Time!}
    \end{center}

    \vspace{1em}

    \textbf{Task:}
    \begin{enumerate}
        \item Create a negative filter program
        \item Test it on a colorful image
        \item What happens if you apply the negative filter twice?
    \end{enumerate}

    \vspace{1em}

    \textbf{Think about it:}
    \begin{itemize}
        \item If you invert an inverted image, what do you get?
        \item Can you prove this mathematically?
    \end{itemize}
\end{frame}

\begin{frame}{Brightness Adjustment}
    \textbf{Making images lighter or darker:}

    \vspace{1em}

    \textbf{Approach:}
    \begin{itemize}
        \item<1-> Add a value to make \textcolor{marigold}{brighter}
        \item<2-> Subtract a value to make \textcolor{stfxblue}{darker}
        \item<3-> Apply to all three color channels
    \end{itemize}

    \vspace{1em}

    \pause

    \textcolor{red}{\textbf{Challenge:}} RGB values must stay in range \textcolor{stfxblue}{0-255!}

    \vspace{1em}

    \pause

    \textbf{Solutions:}
    \begin{itemize}
        \item<6-> If value > 255, set to 255 (\textcolor{marigold}{clamping})
        \item<7-> If value < 0, set to 0 (\textcolor{marigold}{clamping})
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Increasing Brightness}
    \begin{lstlisting}
from PIL import Image

img = Image.open("photo.jpg")
pixels = img.load()
width, height = img.size

amount = 50  # How much to brighten

for x in range(width):
    for y in range(height):
        r, g, b = pixels[x, y]

        # Add to each channel
        new_r = min(r + amount, 255)
        new_g = min(g + amount, 255)
        new_b = min(b + amount, 255)

        pixels[x, y] = (new_r, new_g, new_b)

img.save("brighter.jpg")
img.show()
    \end{lstlisting}

    \textcolor{stfxblue}{\texttt{min()}} ensures we don't exceed 255
\end{frame}

\begin{frame}[fragile]{Decreasing Brightness}
    \begin{lstlisting}
from PIL import Image

img = Image.open("photo.jpg")
pixels = img.load()
width, height = img.size

amount = 50  # How much to darken

for x in range(width):
    for y in range(height):
        r, g, b = pixels[x, y]

        # Subtract from each channel
        new_r = max(r - amount, 0)
        new_g = max(g - amount, 0)
        new_b = max(b - amount, 0)

        pixels[x, y] = (new_r, new_g, new_b)

img.save("darker.jpg")
img.show()
    \end{lstlisting}

    \vspace{0.5em}

    \textcolor{stfxblue}{\texttt{max()}} ensures we don't go below 0
\end{frame}

\begin{frame}{Tinting Images}
    \textbf{What is \textcolor{marigold}{tinting}?}
    \begin{itemize}
        \item<1-> Adding a color "cast" to an image
        \item<2-> Like looking through colored glass
        \item<3-> Useful for artistic effects and moods
    \end{itemize}

    \vspace{1em}

    \pause

    \textbf{Approaches:}
    \begin{enumerate}
        \item<5-> \textcolor{stfxblue}{\textbf{Additive:}} Add more of certain colors
        \item<6-> \textcolor{stfxblue}{\textbf{Multiplicative:}} Scale certain color channels
        \item<7-> \textcolor{stfxblue}{\textbf{Reduction:}} Reduce certain colors (increases others relatively)
    \end{enumerate}

    \vspace{1em}

    \pause

    \textbf{Example effects:}
    \begin{itemize}
        \item<9-> \textcolor{marigold}{Sepia tone} (warm, vintage look)
        \item<10-> \textcolor{blue}{Blue tint} (cool, night-time feel)
        \item<11-> \textcolor{red}{Red tint} (warm, sunset feel)
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Simple Tint: Reduce Blue}
    \begin{lstlisting}
from PIL import Image

img = Image.open("photo.jpg")
pixels = img.load()
width, height = img.size

for x in range(width):
    for y in range(height):
        r, g, b = pixels[x, y]

        # Reduce blue channel by 50%
        new_b = b // 2

        # Keep red and green the same
        pixels[x, y] = (r, g, new_b)

img.save("warm_tint.jpg")
img.show()
    \end{lstlisting}

    \vspace{1em}

    Removing \textcolor{blue}{blue} makes the image appear \textcolor{marigold}{warmer} (more red/yellow)
\end{frame}

\begin{frame}[fragile]{Sepia Tone Filter}
    \textbf{\textcolor{marigold}{Sepia} creates a warm, vintage photograph look:}

    \begin{lstlisting}
from PIL import Image

img = Image.open("photo.jpg")
pixels = img.load()
width, height = img.size

for x in range(width):
    for y in range(height):
        r, g, b = pixels[x, y]

        # Sepia transformation
        new_r = int(0.393*r + 0.769*g + 0.189*b)
        new_g = int(0.349*r + 0.686*g + 0.168*b)
        new_b = int(0.272*r + 0.534*g + 0.131*b)

        # Clamp values
        pixels[x, y] = (min(new_r, 255),
                        min(new_g, 255),
                        min(new_b, 255))

img.save("sepia.jpg")
img.show()
    \end{lstlisting}
\end{frame}

\begin{frame}{Understanding the Sepia Formula}
    \textbf{Why these specific numbers?}

    \vspace{1em}

    The sepia transformation:
    \begin{itemize}
        \item Mixes all three color channels
        \item Emphasizes red and green (warm tones)
        \item De-emphasizes blue (cool tones)
        \item Creates the brownish tint of old photographs
    \end{itemize}

    \vspace{1em}

    \textbf{Notice:}
    \begin{itemize}
        \item Each new color is computed from all three original colors
        \item This is more complex than simple channel manipulation
        \item Creates a specific, recognizable effect
    \end{itemize}

    \vspace{1em}

    \textit{These are standard coefficients used in image processing!}
\end{frame}

\begin{frame}[fragile]{Try It: Color Tints}
    \begin{center}
        \Large \textbf{Activity Time!}
    \end{center}

    \vspace{1em}

    \textbf{Experiment with tinting:}
    \begin{enumerate}
        \item Create a blue tint (reduce red and green)
        \item Create a red tint (reduce blue and green)
        \item Try the sepia filter
        \item Create your own custom tint!
    \end{enumerate}

    \vspace{1em}

    \textbf{Challenge:} Can you make a "cold winter" filter? A "warm sunset" filter?
\end{frame}

\begin{frame}{Posterization}
    \textbf{What is posterization?}
    \begin{itemize}
        \item Reduces the number of colors in an image
        \item Creates a "poster art" or "comic book" effect
        \item Groups similar colors together
    \end{itemize}

    \vspace{1em}

    \textbf{How it works:}
    \begin{itemize}
        \item Divide the 0-255 range into fewer levels
        \item Round each color value to the nearest level
        \item Example: 4 levels instead of 256
    \end{itemize}

    \vspace{1em}

    \textbf{Formula:}
    \begin{center}
        $\text{new\_value} = \lfloor \frac{\text{old\_value}}{\text{step}} \rfloor \times \text{step}$
    \end{center}
\end{frame}

\begin{frame}[fragile]{Posterization Implementation}
    \begin{lstlisting}
from PIL import Image

img = Image.open("photo.jpg")
pixels = img.load()
width, height = img.size

levels = 4  # Number of levels per channel
step = 256 // levels

for x in range(width):
    for y in range(height):
        r, g, b = pixels[x, y]

        # Posterize each channel
        new_r = (r // step) * step
        new_g = (g // step) * step
        new_b = (b // step) * step

        pixels[x, y] = (new_r, new_g, new_b)

img.save("posterized.jpg")
img.show()
    \end{lstlisting}

    \vspace{0.5em}

    Try different numbers of levels!
\end{frame}

\begin{frame}{Threshold Filter}
    \textbf{Creates a pure black and white image (not grayscale):}

    \vspace{1em}

    \begin{itemize}
        \item Each pixel becomes either black or white
        \item No shades of gray
        \item Useful for text, line art, and artistic effects
    \end{itemize}

    \vspace{1em}

    \textbf{Algorithm:}
    \begin{enumerate}
        \item Calculate brightness (or use one channel)
        \item Compare to a threshold value
        \item If above threshold → white
        \item If below threshold → black
    \end{enumerate}

    \vspace{1em}

    \textbf{Typical threshold:} 128 (middle of 0-255 range)
\end{frame}

\begin{frame}[fragile]{Threshold Implementation}
    \begin{lstlisting}
from PIL import Image

img = Image.open("photo.jpg")
pixels = img.load()
width, height = img.size

threshold = 128

for x in range(width):
    for y in range(height):
        r, g, b = pixels[x, y]

        # Calculate brightness
        brightness = (r + g + b) // 3

        # Apply threshold
        if brightness > threshold:
            pixels[x, y] = (255, 255, 255)  # White
        else:
            pixels[x, y] = (0, 0, 0)        # Black

img.save("threshold.jpg")
img.show()
    \end{lstlisting}
\end{frame}

\begin{frame}{Lab Exercise: Build a Filter Function}
    \textbf{Let's organize our code better:}

    \vspace{1em}

    Instead of writing the same nested loop structure every time, create reusable functions!

    \vspace{1em}

    \textbf{Structure:}
    \begin{enumerate}
        \item Define a function for each filter
        \item Pass the image as a parameter
        \item Return the modified image
        \item Easy to combine filters!
    \end{enumerate}

    \vspace{1em}

    \begin{center}
        This is better programming practice!
    \end{center}
\end{frame}

\begin{frame}[fragile]{Filter Functions Example}
    \begin{lstlisting}
from PIL import Image

def grayscale(img):
    pixels = img.load()
    width, height = img.size

    for x in range(width):
        for y in range(height):
            r, g, b = pixels[x, y]
            gray = int(0.299*r + 0.587*g + 0.114*b)
            pixels[x, y] = (gray, gray, gray)

    return img

# Use the function
img = Image.open("photo.jpg")
img = grayscale(img)
img.save("output.jpg")
img.show()
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Combining Filters}
    \textbf{With functions, we can easily chain filters:}

    \begin{lstlisting}
from PIL import Image

# Define your filter functions here...
# def grayscale(img): ...
# def increase_brightness(img, amount): ...
# def negative(img): ...

# Load image
img = Image.open("photo.jpg")

# Apply multiple filters in sequence
img = increase_brightness(img, 30)
img = grayscale(img)

# Or all at once
img = grayscale(increase_brightness(
        Image.open("photo.jpg"), 30))

img.save("processed.jpg")
img.show()
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Lab Activity: Complete Filter Suite}
    \begin{center}
        \Large \textbf{Main Lab Activity!}
    \end{center}

    \vspace{1em}

    \textbf{Create a Python program with these functions:}
    \begin{enumerate}
        \item \texttt{grayscale(img)} - Convert to grayscale
        \item \texttt{negative(img)} - Create negative
        \item \texttt{brighten(img, amount)} - Increase brightness
        \item \texttt{darken(img, amount)} - Decrease brightness
        \item \texttt{sepia(img)} - Apply sepia tone
        \item \texttt{threshold(img, value)} - Black \& white
    \end{enumerate}

    \vspace{1em}

    \textbf{Test each function and save the results!}

    \vspace{0.5em}

    \textbf{Bonus:} Create your own custom filter!
\end{frame}

\begin{frame}{Tips for Lab Success}
    \textbf{Best practices:}

    \vspace{1em}

    \begin{enumerate}
        \item \textbf{Test on small images first}
            \begin{itemize}
                \item Faster to process
                \item Easier to debug
            \end{itemize}

        \item \textbf{Save intermediate results}
            \begin{itemize}
                \item Don't lose your work!
                \item Compare different approaches
            \end{itemize}

        \item \textbf{Use descriptive filenames}
            \begin{itemize}
                \item \texttt{photo\_grayscale.jpg}
                \item \texttt{photo\_negative.jpg}
            \end{itemize}

        \item \textbf{Add comments}
            \begin{itemize}
                \item Explain what each filter does
                \item Note the formulas used
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}{Common Debugging Issues}
    \textbf{If your filter doesn't work:}

    \vspace{1em}

    \begin{enumerate}
        \item \textbf{Check your loops}
            \begin{itemize}
                \item Are you iterating over width and height correctly?
            \end{itemize}

        \item \textbf{Verify value ranges}
            \begin{itemize}
                \item RGB values must be 0-255
                \item Use \texttt{min()} and \texttt{max()} to clamp
            \end{itemize}

        \item \textbf{Integer vs float}
            \begin{itemize}
                \item RGB values must be integers
                \item Use \texttt{int()} to convert
            \end{itemize}

        \item \textbf{Test on a tiny image first}
            \begin{itemize}
                \item Create a 10×10 test image
                \item Print pixel values to debug
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}{Advanced Challenge: Edge Detection Preview}
    \textbf{Looking ahead:}

    \vspace{1em}

    With the concepts learned today, you could also:
    \begin{itemize}
        \item Compare adjacent pixels
        \item Find edges where colors change rapidly
        \item Create sketch-like effects
        \item Blur images by averaging neighbors
    \end{itemize}

    \vspace{1em}

    \textbf{These require:}
    \begin{itemize}
        \item Looking at neighboring pixels
        \item More complex calculations
        \item We'll cover this in later weeks!
    \end{itemize}

    \vspace{1em}

    \begin{center}
        \textit{But you already have the fundamentals!}
    \end{center}
\end{frame}

\begin{frame}{Key Takeaways}
    \textbf{Today you learned:}
    \begin{itemize}
        \item The standard pattern for processing all pixels
        \item How to create grayscale images (two methods)
        \item How to create negative images
        \item How to adjust brightness
        \item How to apply color tints
        \item How to create sepia tone
        \item How to organize filters into functions
    \end{itemize}

    \vspace{1em}

    \begin{center}
        \textbf{You can now create Instagram-style filters from scratch!}
    \end{center}
\end{frame}

\begin{frame}{Understanding Image Processing}
    \textbf{What you've really learned:}

    \vspace{1em}

    \begin{itemize}
        \item \textbf{Algorithms:} Step-by-step procedures to solve problems
        \item \textbf{Data transformation:} Converting data from one form to another
        \item \textbf{Iteration:} Processing large amounts of data systematically
        \item \textbf{Functions:} Organizing code into reusable components
    \end{itemize}

    \vspace{1em}

    \begin{center}
        These are \textit{fundamental computer science concepts}!
    \end{center}

    \vspace{1em}

    You've been learning CS theory while having fun with pictures!
\end{frame}

\begin{frame}{For Next Class}
    \textbf{Before next session:}
    \begin{itemize}
        \item Complete all lab filter functions
        \item Experiment with different images
        \item Try combining multiple filters
        \item Read Chapter 4 of the textbook
        \item Think about: What other transformations could we do?
    \end{itemize}

    \vspace{1em}

    \textbf{Next session:}
    \begin{itemize}
        \item Picture transformations (flip, mirror, rotate)
        \item Copying regions of images
        \item Creating image collages
        \item More advanced manipulations
    \end{itemize}

    \vspace{1em}

    \begin{center}
        \textbf{Questions?}
    \end{center}
\end{frame}

\end{document}
