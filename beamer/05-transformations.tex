\documentclass{csbeamer}

\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}

% Python code styling
\lstset{
    language=Python,
    basicstyle=\ttfamily\scriptsize,
    keywordstyle=\color{blue}\bfseries,
    stringstyle=\color{red},
    commentstyle=\color{green!50!black}\itshape,
    showstringspaces=false,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray}
}

% Course information
\title{Picture Transformations}
\course{CSCI 128: Coding For Problem Solving}
\courseshort{CSCI 128}
\term{Winter 2026}
\author{Dr. Jean-Alexis Delamer}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{Today's Topics}
    \begin{center}
        \Large Moving and transforming images!
    \end{center}

    \vspace{1em}

    \textbf{Learning Objectives:}
    \begin{itemize}
        \item Copy pixels from one image to another
        \item \textcolor{marigold}{Mirror} images horizontally and vertically
        \item \textcolor{stfxblue}{Rotate} images 90 degrees
        \item \textcolor{marigold}{Crop} portions of images
        \item \textcolor{stfxblue}{Scale} images up and down
        \item Understand coordinate transformations
    \end{itemize}

    \vspace{1em}

    \begin{center}
        \textit{Today we manipulate \textcolor{marigold}{\textbf{image structure}}, not just color!}
    \end{center}
\end{frame}

\begin{frame}{A Problem: Repeating Code}
    \textbf{Last classes, we wrote similar code over and over:}

    \vspace{1em}

    \begin{itemize}
        \item Grayscale filter: loop through pixels, transform colors
        \item Negative filter: loop through pixels, transform colors
        \item Sepia filter: loop through pixels, transform colors
        \item Brightness filter: loop through pixels, transform colors
    \end{itemize}

    \vspace{1em}

    \pause

    \textbf{This is repetitive and error-prone!}

    \vspace{1em}

    \pause

    \begin{center}
        \Large \textcolor{marigold}{We need a better way to organize our code.}
    \end{center}

    \vspace{1em}

    \begin{center}
        \onslide<2->{\textit{Enter: \textcolor{stfxblue}{\textbf{Functions!}}}}
    \end{center}
\end{frame}

\begin{frame}{What is a Function?}
    \textbf{A \textcolor{stfxblue}{function} is a reusable block of code with a name.}

    \vspace{1em}

    \textbf{Think of it like a recipe:}
    \begin{itemize}
        \item<1-> Has a name: "Make Grayscale"
        \item<2-> Takes ingredients (inputs): an image
        \item<3-> Follows steps: loop through pixels, average RGB
        \item<4-> Produces a result (output): grayscale image
    \end{itemize}

    \vspace{1em}

    \pause

    \textbf{Benefits:}
    \begin{itemize}
        \item<6-> \textcolor{marigold}{Reusable}: Write once, use many times
        \item<7-> \textcolor{marigold}{Organized}: Each function has one job
        \item<8-> \textcolor{marigold}{Readable}: Code is easier to understand
        \item<9-> \textcolor{marigold}{Maintainable}: Fix bugs in one place
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Function Syntax}
    \textbf{Basic structure of a function:}

    \begin{lstlisting}
def function_name(parameter1, parameter2):
    """Optional description of what function does"""
    # Code goes here
    result = # ... do something ...
    return result
    \end{lstlisting}

    \vspace{1em}

    \textbf{Key parts:}
    \begin{itemize}
        \item \texttt{\textcolor{blue}{def}}: keyword to define a function
        \item \texttt{function\_name}: descriptive name (use snake\_case)
        \item \texttt{(parameters)}: inputs the function needs
        \item \texttt{:} colon (don't forget!)
        \item Indented code block: the function body
        \item \texttt{\textcolor{blue}{return}}: sends result back to caller
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Your First Function: Simple Example}
    \begin{lstlisting}
def greet(name):
    """Greet someone by name"""
    message = "Hello, " + name + "!"
    return message

# Using the function
greeting1 = greet("Alice")
print(greeting1)  # Hello, Alice!

greeting2 = greet("Bob")
print(greeting2)  # Hello, Bob!
    \end{lstlisting}

    \vspace{1em}

    \textbf{What happened:}
    \begin{itemize}
        \item We \textcolor{stfxblue}{defined} the function once
        \item We \textcolor{marigold}{called} it twice with different inputs
        \item Each call returned a different result
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Function Parameters and Arguments}
    \textbf{Parameters vs Arguments:}

    \vspace{1em}

    \begin{itemize}
        \item \textbf{\textcolor{stfxblue}{Parameter}}: Variable in function definition
        \item \textbf{\textcolor{marigold}{Argument}}: Actual value passed when calling
    \end{itemize}

    \vspace{1em}

    \begin{lstlisting}
def add_numbers(a, b):  # a and b are parameters
    """Add two numbers together"""
    total = a + b
    return total

# 5 and 3 are arguments
result = add_numbers(5, 3)
print(result)  # 8

# 10 and 20 are arguments
result2 = add_numbers(10, 20)
print(result2)  # 30
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The Return Statement}
    \textbf{Return sends a value back to the caller:}

    \vspace{1em}

    \begin{lstlisting}
def square(x):
    """Calculate square of a number"""
    result = x * x
    return result

answer = square(5)
print(answer)  # 25

# Can use directly in expressions
total = square(3) + square(4)
print(total)  # 9 + 16 = 25
    \end{lstlisting}

    \vspace{1em}

    \textbf{Important:}
    \begin{itemize}
        \item \texttt{return} exits the function immediately
        \item Code after \texttt{return} doesn't run
        \item Functions without \texttt{return} return \texttt{None}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Functions Without Return}
    \textbf{Not all functions need to return a value:}

    \vspace{1em}

    \begin{lstlisting}
def print_header(title):
    """Print a fancy header"""
    print("=" * 40)
    print(title.upper())
    print("=" * 40)

print_header("My Program")
# ========================================
# MY PROGRAM
# ========================================

print_header("Section 2")
# ========================================
# SECTION 2
# ========================================
    \end{lstlisting}

    \vspace{1em}

    \textbf{This function performs an action but doesn't return anything.}
\end{frame}

\begin{frame}[fragile]{Multiple Parameters}
    \textbf{Functions can take multiple inputs:}

    \begin{lstlisting}
def calculate_area(width, height):
    """Calculate area of a rectangle"""
    area = width * height
    return area

def make_full_name(first, last):
    """Combine first and last name"""
    return first + " " + last

# Using the functions
rect_area = calculate_area(10, 5)
print(rect_area)  # 50

name = make_full_name("John", "Smith")
print(name)  # John Smith
    \end{lstlisting}

    \vspace{1em}

    \textbf{Order matters!} Arguments are assigned to parameters by position.
\end{frame}

\begin{frame}[fragile]{Applying Functions to Images}
    \textbf{Now let's use functions for image processing!}

    \vspace{1em}

    \textbf{Without functions (what we did before):}
    \begin{lstlisting}
# Convert to grayscale
for x in range(width):
    for y in range(height):
        r, g, b = pixels[x, y]
        gray = (r + g + b) // 3
        pixels[x, y] = (gray, gray, gray)

# Apply negative
for x in range(width):
    for y in range(height):
        r, g, b = pixels[x, y]
        new_r = 255 - r
        new_g = 255 - g
        new_b = 255 - b
        pixels[x, y] = (new_r, new_g, new_b)
    \end{lstlisting}

    \textcolor{red}{Lots of repeated code!}
\end{frame}

\begin{frame}[fragile]{With Functions: Much Better!}
    \begin{lstlisting}
def grayscale(img):
    """Convert image to grayscale"""
    pixels = img.load()
    width, height = img.size
    for x in range(width):
        for y in range(height):
            r, g, b = pixels[x, y]
            gray = (r + g + b) // 3
            pixels[x, y] = (gray, gray, gray)
    return img

# Now we can use it easily!
from PIL import Image
img = Image.open("photo.jpg")
img = grayscale(img)
img.save("grayscale.jpg")

# Want to apply it again? Easy!
img2 = Image.open("another.jpg")
img2 = grayscale(img2)  # Same function, different image!
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Building a Filter Library}
    \textbf{We can create many filter functions:}

    \begin{lstlisting}
def grayscale(img):
    # ... implementation ...
    return img

def sepia(img):
    # ... implementation ...
    return img

def brighten(img, amount):
    # ... implementation ...
    return img

# Using our library
img = Image.open("photo.jpg")
img = sepia(img)
img = brighten(img, 30)
img.save("result.jpg")
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Functions Calling Functions}
    \textbf{Functions can use other functions:}

    \begin{lstlisting}
def grayscale(img):
    # ... convert to grayscale ...

def threshold(img, value):
    # ... apply threshold ...

def black_and_white(img):
    """Convert to pure black and white"""
    # First make grayscale, then threshold
    img = grayscale(img)
    img = threshold(img, 128)
    return img

img = Image.open("photo.jpg")
img = black_and_white(img)
img.save("bw.jpg")
    \end{lstlisting}

    \textbf{This is called \textcolor{marigold}{composition}!}
\end{frame}

\begin{frame}[fragile]{Try It: Create Your First Function}

    \textbf{Create a function that doubles a number:}

    \begin{lstlisting}
def double(x):
    """Return twice the input value"""
    # Your code here
    pass # Remove this when you're done

# Test it
print(double(5))   # Should print 10
print(double(21))  # Should print 42
    \end{lstlisting}

    \textbf{Then create a function that takes two numbers and returns their average:}

    \begin{lstlisting}
def average(a, b):
    """Return average of two numbers"""
    # Your code here
    pass # Remove this when you're done
    \end{lstlisting}
\end{frame}

\begin{frame}{Why Functions Matter for Image Processing}
    \textbf{Today we'll create transformation functions:}

    \vspace{1em}

    \begin{itemize}
        \item<1-> \texttt{mirror\_horizontal(img)} - flip left-right
        \item<2-> \texttt{mirror\_vertical(img)} - flip top-bottom
        \item<3-> \texttt{rotate\_90(img)} - rotate clockwise
        \item<4-> \texttt{crop\_image(img, x, y, w, h)} - extract region
        \item<5-> \texttt{scale\_image(img, factor)} - resize
    \end{itemize}

    \vspace{1em}

    \pause

    \textbf{With functions, we can:}
    \begin{itemize}
        \item<7-> Reuse transformations on different images
        \item<8-> Combine transformations easily
        \item<9-> Build a personal image processing library
        \item<10-> Share code with others
    \end{itemize}

    \vspace{1em}

    \begin{center}
        \onslide<11->{\textcolor{marigold}{\textbf{Functions make complex tasks manageable!}}}
    \end{center}
\end{frame}



\begin{frame}[fragile]{Copying Images}
    \textbf{Why copy an image?}
    \begin{itemize}
        \item \textcolor{stfxblue}{Preserve} the original
        \item Create a base for modifications
        \item Combine multiple images
    \end{itemize}

    \pause

    \textbf{Two approaches:}
    \begin{enumerate}
        \item<2-> Use Pillow's built-in \textcolor{marigold}{\texttt{copy()}} method
        \item<3-> Copy pixel-by-pixel (to understand the process)
    \end{enumerate}

    \begin{lstlisting}
from PIL import Image

# Method 1: Built-in copy
img = Image.open("photo.jpg")
img_copy = img.copy()

# Method 2: Manual copy (we'll implement this)
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Copying Pixel by Pixel (As a Function!)}

    \begin{lstlisting}
from PIL import Image

def copy_image(source_img):
    # Create new image with same size
    width, height = source_img.size
    new_img = Image.new("RGB", (width, height))

    src_pixels = source_img.load()
    dst_pixels = new_img.load()

    for x in range(width):
        for y in range(height):
            dst_pixels[x, y] = src_pixels[x, y]

    return new_img

img = Image.open("photo.jpg")
copy = copy_image(img)
copy.show()
    \end{lstlisting}
\end{frame}

\begin{frame}{Mirroring: The Concept}
    \textbf{\textcolor{marigold}{Horizontal mirror} (flip left-right):}
    \begin{itemize}
        \item<1-> Left side becomes right side
        \item<1-> Right side becomes left side
        \item<1-> Like looking in a mirror
    \end{itemize}

    \textbf{\textcolor{stfxblue}{Vertical mirror} (flip top-bottom):}
    \begin{itemize}
        \item<2-> Top becomes bottom
        \item<2-> Bottom becomes top
        \item<2-> Like a reflection in water
    \end{itemize}

    \textbf{Key idea:}
    \begin{itemize}
        \item<3-> Read pixels from one location
        \item<3-> Write to a \textcolor{marigold}{different, calculated} location
    \end{itemize}
\end{frame}

\begin{frame}{Horizontal Mirror: The Math}
    \textbf{For a horizontal mirror:}

    \vspace{1em}

    \begin{itemize}
        \item<1-> Image width: \texttt{W}
        \item<1-> Pixel at position \texttt{x}
        \item<1-> Should map to position \textcolor{stfxblue}{\texttt{W - 1 - x}}
    \end{itemize}

    \vspace{1em}

    \pause

    \textbf{Examples (for width = 100):}
    \begin{itemize}
        \item<2-> \texttt{x = 0} maps to \texttt{100 - 1 - 0 = \textcolor{marigold}{99}}
        \item<3-> \texttt{x = 10} maps to \texttt{100 - 1 - 10 = \textcolor{marigold}{89}}
        \item<4-> \texttt{x = 99} maps to \texttt{100 - 1 - 99 = \textcolor{marigold}{0}}
    \end{itemize}

    \vspace{1em}

    \begin{center}
        \onslide<5->{\textcolor{marigold}{First pixel becomes last, last becomes first!}}
    \end{center}
\end{frame}

\begin{frame}[fragile]{Implementing Horizontal Mirror}

    \begin{lstlisting}
def mirror_horizontal(img):
    """Mirror image horizontally (flip left-right)"""
    width, height = img.size
    mirrored = Image.new("RGB", (width, height))

    src_pixels = img.load()
    dst_pixels = mirrored.load()

    for x in range(width):
        for y in range(height):
            # Get pixel from left side
            color = src_pixels[x, y]
            # Put it on the right side
            dst_pixels[width - 1 - x, y] = color

    return mirrored

img = Image.open("photo.jpg")
mirrored = mirror_horizontal(img)
mirrored.save("mirrored_h.jpg")
mirrored.show()
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Implementing Vertical Mirror}
    \begin{lstlisting}
def mirror_vertical(img):
    """Mirror image vertically (flip top-bottom)"""
    width, height = img.size
    mirrored = Image.new("RGB", (width, height))

    src_pixels = img.load()
    dst_pixels = mirrored.load()

    for x in range(width):
        for y in range(height):
            # Get pixel from top
            color = src_pixels[x, y]
            # Put it on the bottom
            dst_pixels[x, height - 1 - y] = color

    return mirrored

img = Image.open("photo.jpg")
mirrored = mirror_vertical(img)
mirrored.save("mirrored_v.jpg")
mirrored.show()
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Try It: Mirror Transformations}
    \begin{center}
        \Large \textbf{Activity Time!}
    \end{center}

    \vspace{1em}

    \textbf{Tasks:}
    \begin{enumerate}
        \item Implement both mirror functions
        \item Test them on a photo with text or an asymmetric image
        \item What happens if you apply horizontal mirror twice?
        \item What if you apply both horizontal and vertical mirror?
    \end{enumerate}

    \vspace{1em}

    \textbf{Challenge:} Can you create a function that mirrors around both axes at once?
\end{frame}

\begin{frame}{Rotation: The Challenge}
    \textbf{Rotating images is more complex:}

    \vspace{1em}

    \begin{itemize}
        \item For 90° rotation, width and height swap!
        \item Original: 800×600 → Rotated: 600×800
        \item Need to map coordinates differently
    \end{itemize}

    \vspace{1em}

    \textbf{90° clockwise rotation:}
    \begin{itemize}
        \item Top-left becomes top-right
        \item Top-right becomes bottom-right
        \item Bottom-right becomes bottom-left
        \item Bottom-left becomes top-left
    \end{itemize}

    \vspace{1em}

    \textbf{Coordinate transformation:}
    \begin{itemize}
        \item \texttt{new\_x = height - 1 - y}
        \item \texttt{new\_y = x}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Rotating 90° Clockwise}
    \begin{lstlisting}
def rotate_90_clockwise(img):
    """Rotate image 90 degrees clockwise"""
    width, height = img.size
    rotated = Image.new("RGB", (height, width)) # Dimensions are swapped!

    src_pixels = img.load()
    dst_pixels = rotated.load()

    for x in range(width):
        for y in range(height):
            color = src_pixels[x, y]
            # Transform coordinates
            new_x = height - 1 - y
            new_y = x
            dst_pixels[new_x, new_y] = color

    return rotated

img = Image.open("photo.jpg")
rotated = rotate_90_clockwise(img)
rotated.show()
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Rotating 90° Counter-Clockwise}
    \begin{lstlisting}
def rotate_90_counter_clockwise(img):
    """Rotate image 90 degrees counter-clockwise"""
    width, height = img.size
    rotated = Image.new("RGB", (height, width))

    src_pixels = img.load()
    dst_pixels = rotated.load()

    for x in range(width):
        for y in range(height):
            color = src_pixels[x, y]
            # Different transformation
            new_x = y
            new_y = width - 1 - x
            dst_pixels[new_x, new_y] = color

    return rotated

img = Image.open("photo.jpg")
rotated = rotate_90_counter_clockwise(img)
rotated.show()
    \end{lstlisting}
\end{frame}

\begin{frame}{Cropping Images}
    \textbf{Cropping extracts a rectangular region:}

    \vspace{1em}

    \begin{itemize}
        \item Select a rectangular area
        \item Copy just that region to a new image
        \item New image is smaller than original
    \end{itemize}

    \vspace{1em}

    \textbf{Parameters needed:}
    \begin{itemize}
        \item Top-left corner: \texttt{(start\_x, start\_y)}
        \item Width and height of crop region
        \item Or: Bottom-right corner: \texttt{(end\_x, end\_y)}
    \end{itemize}

    \vspace{1em}

    \textbf{Common uses:}
    \begin{itemize}
        \item Focus on subject
        \item Remove unwanted borders
        \item Extract specific regions for analysis
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Implementing Crop}
    \begin{lstlisting}
def crop_image(img, start_x, start_y, width, height):
    """Crop a rectangular region from an image"""
    # Create new image with crop dimensions
    cropped = Image.new("RGB", (width, height))
    src_pixels = img.load()
    dst_pixels = cropped.load()

    # Copy the selected region
    for x in range(width):
        for y in range(height):
            # Read from offset position in source
            color = src_pixels[start_x + x, start_y + y]
            # Write to normal position in destination
            dst_pixels[x, y] = color

    return cropped

# Using our function with 5 arguments!
img = Image.open("photo.jpg")
cropped = crop_image(img, 100, 50, 200, 300)
cropped.show()
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Pillow's Built-in Crop}
    \textbf{Pillow has a convenient crop method:}

    \begin{lstlisting}
from PIL import Image

img = Image.open("photo.jpg")

# Define crop box: (left, top, right, bottom)
box = (100, 50, 300, 350)
cropped = img.crop(box)

cropped.show()
    \end{lstlisting}

    \textbf{Parameters:}
    \begin{itemize}
        \item \texttt{left}: x-coordinate of left edge
        \item \texttt{top}: y-coordinate of top edge
        \item \texttt{right}: x-coordinate of right edge (exclusive)
        \item \texttt{bottom}: y-coordinate of bottom edge (exclusive)
    \end{itemize}


    \textit{Use this for efficiency, but understand the manual version!}
\end{frame}

\begin{frame}{Scaling Images}
    \textbf{Scaling changes image dimensions:}

    \vspace{1em}

    \begin{itemize}
        \item \textbf{Scale up:} Make image larger
        \item \textbf{Scale down:} Make image smaller
        \item Must decide what to do with pixels
    \end{itemize}

    \vspace{1em}

    \textbf{Challenges:}
    \begin{itemize}
        \item Scaling up: Need to create new pixels
        \item Scaling down: Need to combine/discard pixels
        \item Simple approach: Nearest neighbor
        \item Better approach: Interpolation (built into Pillow)
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Scaling with Pillow}
    \begin{lstlisting}
from PIL import Image

img = Image.open("photo.jpg")
width, height = img.size

# Scale to specific dimensions
scaled = img.resize((400, 300))

# Scale by a factor
new_width = width * 2
new_height = height * 2
scaled_up = img.resize((new_width, new_height))

# Scale down by half
scaled_down = img.resize((width // 2, height // 2))

scaled.show()
    \end{lstlisting}

    \textbf{Note:} \texttt{resize()} uses good interpolation by default
\end{frame}

\begin{frame}[fragile]{Maintaining Aspect Ratio}
    \textbf{Helper functions make common tasks easy:}

    \begin{lstlisting}
def scale_by_factor(img, factor):
    """Scale image by a multiplication factor"""
    width, height = img.size
    new_width = int(width * factor)
    new_height = int(height * factor)
    return img.resize((new_width, new_height))

def scale_to_width(img, new_width):
    """Scale image to specific width, maintain aspect ratio"""
    width, height = img.size
    factor = new_width / width
    new_height = int(height * factor)
    return img.resize((new_width, new_height))

img = Image.open("photo.jpg")
half_size = scale_by_factor(img, 0.5)
width_400 = scale_to_width(img, 400)
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Try It: Transformations}
    \begin{center}
        \Large \textbf{Activity Time!}
    \end{center}

    \vspace{1em}

    \textbf{Create a transformation toolkit:}
    \begin{enumerate}
        \item Create a crop function
        \item Create a scale function that maintains aspect ratio
    \end{enumerate}

    \vspace{1em}

    \textbf{Test each function and save results!}

    \vspace{0.5em}

    \textbf{Challenge:} Can you rotate an image 180°? (Hint: Multiple ways!)
\end{frame}

\begin{frame}[fragile]{Combining Transformations}
    \textbf{Functions make it easy to chain transformations:}

    \begin{lstlisting}
img = Image.open("photo.jpg")

# Crop, then mirror, then rotate
img = crop_image(img, 50, 50, 400, 300)
img = mirror_horizontal(img)
img = rotate_90_clockwise(img)

img.show()
    \end{lstlisting}

    \vspace{1em}

    \textbf{Order matters!}
    \begin{itemize}
        \item Crop then rotate $\neq$ rotate then crop
        \item Dimensions change with each transformation
        \item Plan your sequence carefully
        \item \textcolor{marigold}{Functions make experimentation easy!}
    \end{itemize}
\end{frame}

\begin{frame}{Practical Applications}
    \textbf{Real-world uses:}

    \vspace{1em}

    \begin{itemize}
        \item \textbf{Photo editing:} User wants to rotate/crop
        \item \textbf{Thumbnails:} Scale down for web display
        \item \textbf{Collages:} Combine multiple images
        \item \textbf{Batch processing:} Auto-orient photos
        \item \textbf{Data augmentation:} ML training (flip/rotate)
        \item \textbf{Image standardization:} Same size for processing
    \end{itemize}

    \vspace{1em}

    \begin{center}
        These are foundational operations in image software!
    \end{center}
\end{frame}

\begin{frame}{For Next Class}

    \textbf{Next session:}
    \begin{itemize}
        \item More practice with functions
        \item Combining multiple images
        \item Creating collages
        \item Overlaying images
        \item Blending effects
    \end{itemize}

    \vspace{1em}

    \begin{center}
        \textbf{Questions?}
    \end{center}
\end{frame}

\end{document}
